[문제출처](https://programmers.co.kr/learn/courses/30/lessons/42748?language=python3)

#### 예시

array = [1, 5, 2, 6, 3, 7, 4]  
commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3]]  
return = [5, 6, 3]

## 답안

```py
def solution(array, commands):
    answer = []
    for command in commands:
        i,j,k = command             #command가 [2, 5, 3]이라면
                                    #i = 2, j = 5, k = 3
        answer.append(list(sorted(array[i-1:j]))[k-1])
        # list()는 넣어도되고 안 넣어도 될듯!
    return answer
```

## 궁금증

### 1. `commands`는 2차원 배열인데, `for command in commands:` 이 문장이 어떻게 돌아가는지 궁금하다.

#### - Python for문 기본 사용법 :

- C언어 개열의 for문에서는 인덱스(카운터 변수)와 조건을 이용해서 작성
  ```c
  for(int i = 0; i < 10; i++)
  {
      ,,,
  }
  ```
- Python for문은 C언어 계열과 달리 인덱스를 사용하지 않는다.
  - Python의 for문은 다른 언어의 foreach문에 해당한다. 즉, 변수가 `range()`안에 값에 도달할 때까지 반복하는 느낌!
  - **리스트(배열) 등 개체 요소가 차례로 변수에 할당되어 처리된다.**
- 예시

```py
1 = ['Alice', 'Bob', 'Charlie']
for name in 1:
    print(name)
#Alice
#Bob
#Charlie
```

> C언어에 익숙해서 이 부분을 이해하기 힘들었던 것 같다.

#### **_적용_**

- `for command in commands:` 안에서 `commands`가 [[2, 5, 3], [4, 4, 1], [1, 7, 3]] 이라면 차례대로

1. command = [2, 5, 3]
2. command = [4, 4, 1]
3. command = [1, 7, 3]  
   값을 가지게 될 것이다.

### 2. `.append()` 함수의 의미 + 비슷한 의미의 `.extend()` , `insert()` 함께 학습 [참고](https://ooyoung.tistory.com/117)

#### - **append()**

array.append(x) 형태로 사용한다.  
 append는 덧붙인다는 뜻으로 괄호( ) 안에 값을 입력하면 새로운 요소를 array **맨 끝에 객체**로 추가한다. 요소를 추가할 때는 객체로 추가하게 되는데, 입력한 값이 리스트와 같은 반복 가능한 **iterable 자료형이더라도 객체**로 저장한다.

```py
>>> nums = [1, 2, 3]
>>> nums.append(4) [1, 2, 3, 4]
>>> nums.append([5, 6]) [1, 2, 3, 4, [5, 6]]
# 리스트가 하나의 객체로 추가되었음
```

> **iterable 이란 반복 가능하다는 뜻**이다. 한 번에 하나씩 자료를 반환할 수 있는 파이썬 객체이다. 간단히 말해 for 문으로 그 값을 출력 할 수 있는 것을 의미한다.

#### - **extend()**

array.extend(iterable) 형태로 사용한다. 입력한 iterable 자료형의 항목 각각을 array의 끝에 하나씩 추가한다. append와 동일하게 요소를 array의 끝에 추가하지만 append와 다른 점은 괄호( ) 안에는 iterable 자료형만 올 수 있다는 것이다. iterable 자료형이 아닌 경우 TypeError가 발생한다.

```py
 >>> nums = [1, 2, 3]
 >>> nums.extend([4, 5])
 [1, 2, 3, 4, 5]
#리스트로 주어진 [4, 5]의 요소가 각각 추가 되었음

 >>> a = [10]
 >>> nums.extend(a)
 [1, 2, 3, 4, 5, 10]
```

      그런데 요소 하나만 추가한다면 굳이 extend 함수를 사용하기보다는 append 함수를 사용하는 것이 편리하겠다. 반면 append 함수는 iterable 자료형의 요소를 각각 추가하는 것이 불가능하니 그럴 때는 extend 함수를 사용할 수 있겠다.

#### - **insert()**

array.insert(i, x) 형태로 사용한다. **array의 원하는 위치 i 앞에 추가할 값 x를 삽입할 수 있다. i는 위치를 나타내는 인덱스를 숫자를 입력한다.** 음수를 입력하면 배열의 끝을 기준으로 처리된다. 추가할 값 x는 객체로 추가되며**iterable 자료형이더라도 객체로 저장된다.**

```py
>>> nums = [1, 2, 3]
>>> nums.insert(0, [10, 20]) # 0번째(맨앞에) 추가
[[10, 20], 1, 2, 3]

>>> nums.insert(-1, 100)  # 끝에서 1번째 전에 추가
>>> print(nums)
[[10, 20], 1, 2, 100, 3]  # 리스트 맨 끝에 저장되지 않음
```

#### 정리

1. append 함수  
   array.append(x) 형태로 사용한다. x를 arry의 맨 끝에 객체로 추가다. x가 iterable 자료형이더라도 전체를 하나의 객체로 해서 요소로 추가한다.

2. extend 함수  
   array.extend(iterable) 형태로 사용한다. iterable의 각 요소를 하나씩 array의 끝에 요소로 추가한다. append 함수와 다른 점은 괄호 안에 iterable 자료형만 올 수 있다.

3. insert 함수  
   array.insert(i, x) 형태로 사용한다. 원하는 위치 i에 x를 삽입할 수 있다. 값 x는 객체로 추가된다. append 함수와 마찬가지로 iterable 자료형이더라도 하나의 요소로 삽입된다.

### 3. 배열(array)은 알고 있는데 리스트(list)란?

[참고](https://jy-tblog.tistory.com/38)

#### - 배열(array)

- 인덱스(index) : 각 원소의 번호로 0번부터 시작하며, 해당 원소에 접근한다
- 인덱스에 따라 값을 유지하므로 원소가 삭제되어도 빈자리가 남게되어 메모리가 낭비된다.
- 처음 크기를 10으로 지정한다면 5개의 데이터만 저장하더라도 실제 배열의 크기는 10이다.
- 하지만 삽입과 삭제의 경우 연속적인 형태 유지를 위해 shift 연산을 해야함.

#### - 리스트(list)

- 배열의 문제점을 해결하기 위한 자료구조

- 리스트의 핵심은 원소들 간의 순서로 순서가 있는 데이터의 모임이 리스트이며 리스트를 다른 이름으로 시퀀스(sequence)라고도 부른다.

- 배열에서 인덱스는 유일무이한 식별자이지만 리스트에서는 몇 번째 데이터인지 정도의 의미를 가진다.
  > [리스트 관련 추가내용](https://blockdmask.tistory.com/425)

#### - Python : 기본 리스트, 배열 지원 X

최근 언어들은 리스트를 기본으로 제공한다.
즉, 내가 Python에서 배열이라 생각했던 것은 착각이고 리스트(list)라는 새로운 자료구조 형태라는 것을 기억하자.

> 맞나?

#### - 2차원 리스트(list) [출처](https://dojang.io/mod/page/view.php?id=2291)

<img src = "https://media.vlpt.us/images/yeonu/post/6b94cfd6-7e1e-462c-87be-aff243e5f95e/h.png" width = "500" height = "300">

- 리스트[세로인덱스(행)][가로인덱스(열)] = 값
  > **주의 : 가로 세로 모두 0부터 시작하는 것을 잊지말자!**
- 예제

```py
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> a[2][1]           # 세로 인덱스 2, 가로 인덱스 0인 요소 출력
60
>>> a[0][1] = 1000    # 세로 인덱스 0, 가로 인덱스 1인 요소에 값 할당
>>> a[0][1]
1000
```

### 4. `(list(sorted(array[i-1:j]))[k-1])` 집중 탐구

#### - list() : 리스트 만들기

```py
d = list()
# d라는 리스트 생성, 해당 리스트는 비어있다.
```

#### - sorted() [참고](https://blockdmask.tistory.com/466)

리스트.sort()와 같은 의미(리스트 메소드)이긴하지만, .sort()는 해당 리스트의 값을 정렬해서 변경시켜버리는 명령어.

```py
a = [0, 2, 8, 1, 7]
a.sort()
# a = [0, 1, 2, 7, 8]

a = [0, 2, 8, 1, 7]
b = sorted(a)
# a = [0, 2, 8, 1, 7]
# b = [0, 1, 2, 7, 8]
```

즉, ** 리스트.sort()와 sorted(리스트)의 가장 큰 차이는
**리스트.sort() 는 본체의 리스트를 정렬해서 변환하는 것**이고,
**sorted(리스트) 는 본체 리스트는 내버려두고, 정렬한 새로운 리스트를 반환하는 것\*\*

#### - `array[i-1:j]` : slicing [참고](https://wikidocs.net/2849)

- slicing 예시

```py
>>> kospi_top10 = ['삼성전자', 'SK하이닉스', '현대차', '한국전력', '아모레퍼시픽', '제일모직', '삼성전자우', '삼성생명', 'NAVER', '현대모비스']

>>> kospi_top5 = kospi_top10[0:5]
>>> kospi_top5
['삼성전자', 'SK하이닉스', '현대차', '한국전력', '아모레퍼시픽']

>>> kospi_top10[5:10]
['제일모직', '삼성전자우', '삼성생명', 'NAVER', '현대모비스']
>>> kospi_top10[5:]
['제일모직', '삼성전자우', '삼성생명', 'NAVER', '현대모비스']
# 6번째부터 끝까지(6번째 포함)
>>> kospi_top10[:5]
['삼성전자', 'SK하이닉스', '현대차', '한국전력', '아모레퍼시픽']
# 처음부터 6번째까지전(6번쨰 포함X)
#인덱스는 0부터 시작하는걸 꼭 인지하고 헷갈리지말자!
```

> 인덱스 안 헷갈리고 문제 풀기 위한 나만의 방법

_ex) sth[5:10] 라면_

1. 인덱스 5 <=> 6번 째, 인덱스 10 <=> 11번 째
2. [start:End], start는 포함, End는 포함X
3. 따라서, 6번 째부터 ~ 11번 째전까지(즉, 10번 째까지)  
   ('start는 6번 째로 바꾸고, End는 안 바꾸고 바로 10번 째까지'라고 생각해도 좋을듯!)
